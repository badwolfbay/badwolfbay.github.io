{"meta":{"title":"BADWOLFBAY","subtitle":"Run,You Clever Boy!","description":"RUN,YOU CLEVER BOY","author":"BADWOLF","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-09-21T14:12:55.000Z","updated":"2017-09-21T14:12:55.000Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"Blog","date":"2017-08-22T05:56:03.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"blog/index.html","permalink":"http://yoursite.com/blog/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-09-19T14:24:41.000Z","updated":"2017-09-20T05:25:55.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"首页","date":"2017-08-22T05:56:03.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"e9-a6-96-e9-a1-b5-trashed/index.html","permalink":"http://yoursite.com/e9-a6-96-e9-a1-b5-trashed/index.html","excerpt":"","text":"欢迎来到您的站点！这是您的主页，也就是大多数访客第一次造访时看到的页面。"},{"title":"示例页面","date":"2017-08-18T11:21:01.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"sample-page-trashed/index.html","permalink":"http://yoursite.com/sample-page-trashed/index.html","excerpt":"","text":"这是示范页面。页面和博客文章不同，它的位置是固定的，通常会在站点导航栏显示。很多用户都创建一个“关于”页面，向访客介绍自己。例如： 欢迎！我白天是个邮递员，晚上就是个有抱负的演员。这是我的博客。我住在天朝的帝都，有条叫做Jack的狗。 ……或这个： XYZ Doohickey公司成立于1971年，自从建立以来，我们一直向社会贡献着优秀doohickies。我们的公司总部位于天朝魔都，有着超过两千名员工，对魔都政府税收有着巨大贡献。 而您，作为一个WordPress用户，我们建议您访问控制板，删除本页面，然后添加您自己的页面。祝您使用愉快！"},{"title":"tags","date":"2017-09-19T14:26:55.000Z","updated":"2017-09-20T05:28:06.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MAC上安装docker","slug":"install-docker-via-dlite","date":"2017-09-21T13:09:47.000Z","updated":"2017-09-21T13:19:49.000Z","comments":true,"path":"2017/09/21/install-docker-via-dlite/","link":"","permalink":"http://yoursite.com/2017/09/21/install-docker-via-dlite/","excerpt":"在MAC上安装docker for mac后，docker程序会在用户登录mac后自动启动，而如果用户没有登录，而是通过ssh远程登录的情况下，docker是无法启动的，在配置launchctl也无法配置自动启动命令。 经过一番搜索后，可以使用dlite来通过命令启动docker。 1.项目地址： https://github.com/nlf/dlite 2.在release中下载编译好的二进制文件，将文件放到PATH下，最简单的放到/usr/local/bin/目录下，然后执行 sudo dlite init 注意需要给dlite可执行权限 chmod +x dlite 3.执行命令后，开始询问创建虚拟机的参数，一路回车，但是最后报错 1234Saving configuration: doneCreating ssh key pair: doneAdding host to ssh config: ERROR!Adding host to ssh config: | open /var/root/.ssh/config: no such file or directory 手动创建.ssh目录以及config文件 sudo mkdir /var/root/.ssh sudo touch /var/root/.ssh/config 然后重新执行sudo dlite init","text":"在MAC上安装docker for mac后，docker程序会在用户登录mac后自动启动，而如果用户没有登录，而是通过ssh远程登录的情况下，docker是无法启动的，在配置launchctl也无法配置自动启动命令。 经过一番搜索后，可以使用dlite来通过命令启动docker。 1.项目地址： https://github.com/nlf/dlite 2.在release中下载编译好的二进制文件，将文件放到PATH下，最简单的放到/usr/local/bin/目录下，然后执行 sudo dlite init 注意需要给dlite可执行权限 chmod +x dlite 3.执行命令后，开始询问创建虚拟机的参数，一路回车，但是最后报错 1234Saving configuration: doneCreating ssh key pair: doneAdding host to ssh config: ERROR!Adding host to ssh config: | open /var/root/.ssh/config: no such file or directory 手动创建.ssh目录以及config文件 sudo mkdir /var/root/.ssh sudo touch /var/root/.ssh/config 然后重新执行sudo dlite init 而后报新的错误 123Creating tool binaries: done Creating tool binaries: |Creating disk: ERROR!signal: trace/BPT trap 需要安装依赖 brew install opam golang libev opam init eval opam config env opam install uri qcow.0.7.0 conf-libev logs fmt qcow-format 然后仍然报错,信息 12Next we'll run a few steps that require sudo, you may be prompted for your password. Creating /etc/resoModifying /etc/exports: ERROR! done 根据github上的issue https://github.com/nlf/dlite/issues/218 问题在于执行sudo dlite init是不能加sudo,再次执行 dlite init 即可 dlite start 执行docker命令报错 12$ docker psError response from daemon: Unable to connect to the virtual machine 执行ssh docker@local.docker 报错。 正常Dlite 会自动添加 local.docker 到 OS X 的 hosts 文件内。 需要手动更改hosts文件 dlite ip 查看ip 为192.168.64.2 sudo vi /etc/hosts 增加一行 1192.168.64.2 local.docker 后执行docker ps就可以了 12$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 可参考链接 http://holys.im/2016/02/22/run-docker-on-osx-with-dlite/","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"Go 指南学习笔记九","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b9-9d","date":"2017-09-15T13:17:04.000Z","updated":"2017-09-19T14:20:32.000Z","comments":true,"path":"2017/09/15/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b9-9d/","link":"","permalink":"http://yoursite.com/2017/09/15/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b9-9d/","excerpt":"","text":"1.接口，接口为一组方法定义的集合 和其它语言不同，类型实现接口不需要显示声明，不需要implements关键字 定义接口和实现接口互不依赖 1234567891011121314151617181920212223242526272829303132333435type Abser interface &#123; Abs() float64&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat 实现了 Abser a = &amp;v // a *Vertex 实现了 Abser // 下面一行，v 是一个 Vertex（而不是 *Vertex） // 所以没有实现 Abser。 a = v fmt.Println(a.Abs())&#125;","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记八","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ab","date":"2017-09-11T05:22:53.000Z","updated":"2017-09-19T14:21:42.000Z","comments":true,"path":"2017/09/11/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ab/","link":"","permalink":"http://yoursite.com/2017/09/11/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ab/","excerpt":"","text":"1.结构体方法 Go语言不像JAVA，没有类的定义，但是依然可以为结构体定义方法。 123456789101112131415package mainimport ( \"fmt\" \"math\")type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X * v.X + v.Y * v.Y)&#125;func main()&#123; v := &amp;Vertex&#123;3,4&#125; fmt.Println(v.Abs()) // 5&#125; 2.还可以对包内任意类型定义任意方法，但是不能对包外的类型或者基础类型定义方法 1234567891011121314151617181920package mainimport ( \"fmt\" \"math\")type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;func main()&#123; f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) // 1.4142135623730951&#125; 3.方法可以与类型和类型的指针相关联 如1中的Abs方法是作用的*Vertex指针类型上 1234func (v *Vertex) Scale(f float64)&#123; v.X = v.X * f v.Y = v.Y * f&#125; 与 1234func (v Vertex) Scale(f float64)&#123; v.X = v.X * f v.Y = v.Y * f&#125; 的区别 v := *Vertex(3,5) v.Scale(5) 前边的是用*Vertex指针类型接受，是引用传递，所以会改变接受者v的原始值，而后边的是用变量（后者说是对象）接受，是值传递，会对v进行一份copy,而不会对原始值做更改。","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记七","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-83","date":"2017-09-07T13:37:40.000Z","updated":"2017-09-19T14:22:42.000Z","comments":true,"path":"2017/09/07/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-83/","link":"","permalink":"http://yoursite.com/2017/09/07/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-83/","excerpt":"","text":"闭包 函数也是一个值，也可以像其它值一样传递。函数值也可以作为参数或者返回值 闭包是一个函数值，他引用了函数体之外的变量 这个函数值可以对引用的变量进行修改或者赋值 1234567891011121314151617181920package mainimport ( \"fmt\")func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println(pos(i), neg(-2*i)) &#125;&#125; 输出结果： 12345678910111213[Running] go run \"/Users/badwolf/Documents/go/hello/tempCodeRunnerFile.go\"0 01 -23 -66 -1210 -2015 -3021 -4228 -5636 -7245 -90[Done] exited with code=0 in 0.605 seconds","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"zookeeper安装","slug":"zookeeper-e5-ae-89-e8-a3-85","date":"2017-09-06T02:33:09.000Z","updated":"2017-09-21T13:17:31.000Z","comments":true,"path":"2017/09/06/zookeeper-e5-ae-89-e8-a3-85/","link":"","permalink":"http://yoursite.com/2017/09/06/zookeeper-e5-ae-89-e8-a3-85/","excerpt":"","text":"1.下载安装文件，下载地址：http://mirrors.hust.edu.cn/apache/zookeeper/ 这里的下载的版本为zookeeper-3.4.10.tar.gz 2.解压下载的安装文件 tar -zxvf&nbsp;zookeeper-3.4.10.tar.gz 3.修改配置文件 zookeeper-3.4.10/confmv zoo_sample.cfg zoo.cfg zoo.cfg可以根据需要修改配置信息,如clientPort=2181 4.启动zookeeper cd ../bin./zkServer.sh start 启动成功信息： ZooKeeper JMX enabled by default Using config: /root/zookeeper-3.4.10/bin/../conf/zoo.cfg Starting zookeeper … STARTED 查看端口占用信息： netstat -an|grep 2181 5.客户端连接测试 ./zkCli.sh -server 127.0.0.1 连接成功后执行help命令可以查看帮助命令 [zk: 127.0.0.1(CONNECTED) 0] help ZooKeeper -server host:port cmd args stat path [watch] set path data [version] ls path [watch] delquota [-n|-b] path ls2 path [watch] setAcl path acl setquota -n|-b val path history&nbsp; redo cmdno printwatches on|off delete path [version] sync path listquota path rmr path get path [watch] create [-s] [-e] path data acl addauth scheme auth quit&nbsp; getAcl path close&nbsp; connect host:port","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"Go 指南学习笔记六","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ad","date":"2017-09-05T01:48:36.000Z","updated":"2017-09-19T14:23:32.000Z","comments":true,"path":"2017/09/05/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ad/","link":"","permalink":"http://yoursite.com/2017/09/05/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ad/","excerpt":"","text":"1.map map在使用之前必须使用make来创建，值为nil的map是空的，并且不能对它赋值 1234567891011121314151617package mainimport ( \"fmt\")type Vertex struct&#123; Lat, Long float64&#125;var m map[string]Vertexfunc main() &#123; m = make(map[string]Vertex) m[\"Bell Labs\"] = Vertex&#123;40.68433, -74.39967&#125; fmt.Println(m[\"Bell Labs\"])// &#123;40.68433 -74.39967&#125;&#125; 2.和结构体语法类似 12345var n = map[string]Vertex &#123; \"Bell Labs\": Vertex&#123;40.68433, -74.39967,&#125;, \"Google\":Vertex&#123;37.42202, -122.08408,&#125;,&#125;fmt.Println(n) //map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;] 如果map的value值只是一个类型，可以在{}中将类型省略 1234var k = map[string]Vertex&#123; \"Bell Labs\": &#123;40.68433, -74.39967&#125;, \"Google\": &#123;37.42202, -122.08408&#125;,&#125; 3.修改map 插入或者修改元素: m[key] =&nbsp;elem 获得元素:&nbsp;elem = m[key] 删除元素: delete(m,key) 检测是否存在: elem, ok = m[key]","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记五","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-94","date":"2017-09-03T15:28:42.000Z","updated":"2017-09-19T14:25:04.000Z","comments":true,"path":"2017/09/03/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-94/","link":"","permalink":"http://yoursite.com/2017/09/03/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-94/","excerpt":"","text":"1.数组：类型[n]T是有n个值的类型为T的数组 var a [10] int 变量a是一个有10个整数的数组。 数组不能改变大小 12345678910package mainimport \"fmt\"func main() &#123; var a [10]string a[0] = \"hello\" a[1] = \"world\" fmt.Println(a[0], a[1]) //hello world fmt.Println(a) // [hello world&#125; 2.slice(切片),[]T为一个类型为T的slice,len(s)返回切片s的长度 123456789101112131415s := []int&#123;2, 3, 5, 7, 11, 13&#125;fmt.Println(\"s == \", s)for i := 0; i &lt; len(s); i++ &#123; fmt.Printf(\"s[%d] = %d\\n\", i, s[i])&#125;//输出结果s == [2 3 5 7 11 13]s[0] = 2s[1] = 3s[2] = 5s[3] = 7s[4] = 11s[5] = 13 3.slice 可以包含任意的类型，包括另一个 slice。 123456game := [][] string&#123; []string&#123;\"\",\"\",\"\"&#125;, []string&#123;\"\",\"\",\"\"&#125;, []string&#123;\"\",\"\",\"\"&#125;,&#125; 4.对slice切片 s[lo:hi] // 包含lo元素，不包含hi元素 5.构造slice,slice由make创建，这会分配一个全是零值的数组并返回一个slice并指向这个数组 1a := make([]int, 5) 可以传递第三个参数来执行容量 1b := make([]int, 0 , 5) // len(b) = 0, cap(b) = 5 如： 1234567891011121314func printlnSlice(s string, x []int) &#123; fmt.Printf(\"%s len=%d, cap=%d %v\\n\", s, len(x), cap(x), x)&#125;func main() &#123; a := make([]int, 5) printlnSlice(\"a\", a) // a len=5, cap=5 [0 0 0 0 0] b := make([]int, 0, 5) printlnSlice(\"b\", b) // b len=0, cap=5 [] c := b[:2] printlnSlice(\"c\", c) // c len=2, cap=5 [0 0] d := c[2:5] printlnSlice(\"d\", d) //d len=3, cap=3 [0 0 0]&#125; 6.向slice结尾添加元素，append 1234var a []intappend(a, 0)append(a, 1)append(a, 2, 3, 4) 如果slice底层数组的不能分配更多的数组时，会自动分配一个更大的数组，返回的slice指向新的数组。 7.切片是数组之上的抽象数据类型。 初始化不同,切片不需要指定固定长度:var a [10]int//数组var a []int//切片 切片的零值是nil 更多的slice切片：用法与本质","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记四","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-9b-9b","date":"2017-09-02T12:57:40.000Z","updated":"2017-09-19T14:25:52.000Z","comments":true,"path":"2017/09/02/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-9b-9b/","link":"","permalink":"http://yoursite.com/2017/09/02/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-9b-9b/","excerpt":"","text":"1.结构体struct 12345678910type Vertex struct &#123; X int Y int&#125;func main()&#123; v := Vertex&#123;1,2&#125; v.X = 4 fmt.Println(v.X) // 4&#125; 2.结构体指针 1234v := Vertex&#123;1,2&#125;p := &amp;amp;vp.X = 1e9fmt.Println(p.X) //1000000000 3.结构体语法，可以仅列出部分字段；&amp;可以指向结构体的指针 1234567var ( v1 = Vertex&#123;1, 2&#125; v2 = Vertex&#123;X: 1&#125; v3 = Vertex&#123;&#125; p = *Vertex&#123;1, 2&#125;)fmt.Println(v1, v2, v3, p)//&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125; *&#123;1 2&#125;","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记三","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-89","date":"2017-09-01T12:45:41.000Z","updated":"2017-09-19T14:26:16.000Z","comments":true,"path":"2017/09/01/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-89/","link":"","permalink":"http://yoursite.com/2017/09/01/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-89/","excerpt":"","text":"1.指针：指针保存了变量的内存地址。 T是指向类型T的值指针，其零值是nil *符号会生成一个其作用对象的指针 12345678var p *intfmt.Println(p)i := 42p = *ifmt.Println(p) 输出结果为 *表示指针指向底层的值 1fmt.Println(*p) 并且可以通过修改指针修改底层的值 1*p = 21 这就是常说的”间接引用”。与C语言不同，go语言的指针没有运算。","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"利用Dockerhub+github自定义制作镜像","slug":"e5-88-a9-e7-94-a8dockerhubgithub-e8-87-aa-e5-ae-9a-e4-b9-89-e5-88-b6-e4-bd-9c-e9-95-9c-e5-83-8f","date":"2017-08-31T15:00:13.000Z","updated":"2017-09-19T13:59:19.000Z","comments":true,"path":"2017/08/31/e5-88-a9-e7-94-a8dockerhubgithub-e8-87-aa-e5-ae-9a-e4-b9-89-e5-88-b6-e4-bd-9c-e9-95-9c-e5-83-8f/","link":"","permalink":"http://yoursite.com/2017/08/31/e5-88-a9-e7-94-a8dockerhubgithub-e8-87-aa-e5-ae-9a-e4-b9-89-e5-88-b6-e4-bd-9c-e9-95-9c-e5-83-8f/","excerpt":"","text":"Dockerhub可以根据github工程中Dockerfile自动生成镜像，一般情况下，我们需要google下gcr的镜像，因为网络原因连接不上，我们可以将Dockerfile文件提交到github,然后生成我们自己的镜像，如： 前提是已经注册自己的Dockerhub帐号，登录https://hub.docker.com 点击右上角Create -&gt; Create Automated Build 后登录自己的github帐号 从自己的github工程中选择要创建镜像的工程 后输入要生成的镜像名称 在Build Setting的Tab页中输入Dockerfile的位置以及tag /目录为相对于github中工程的位置，如github中Dockerfile在/centos下 则输入/centos，再点击save changes后，点击Trigger后就可以构建镜像了，后续如果github中代码有更改，构建动作会自动触发。点击build details可以查看每次构建日志","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记二","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-8c","date":"2017-08-30T13:18:46.000Z","updated":"2017-09-19T14:27:52.000Z","comments":true,"path":"2017/08/30/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-8c/","link":"","permalink":"http://yoursite.com/2017/08/30/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-8c/","excerpt":"","text":"1.for循环 go语言只有一个循环语句，即for. 1234sum := 0for i:= 0;i&lt;10;i++&#123; sum += i&#125; 不像java,python等，条件表达式不需要()小括号，循环体需要{} 初始化条件和后置判断条件不是必须的，如for ; i&lt;10; {} 在java等语言中while循环在go语言中写法 123for i &lt; 10 &#123; sum += i&#125; 死循环 123for &#123; sum += i&#125; 2.if语句 同for循环一样,if语句的判断条件语句也不需要() 12if i&lt;10 &#123;&#125; 同for循环一样，条件之前也可以是一个简单的语句 1234567i := 10if j := 10; i&lt;j &#123; return j&#125; else &#123; return i&#125; 3.switch语句 123456789101112131415161718package mainimport ( \"fmt\" \"runtime\")func main() &#123; fmt.Print(\"Go runs on \") switch os := runtime.GOOS; os &#123; case \"darwin\": fmt.Println(\"OS X.\") case \"linux\": fmt.Println(\"Linux.\") default: fmt.Printf(\"%s.\", os) &#125;&#125; 按照条件从上到下执行，直到匹配到成功为止，执行成功后，后边的条件不再执行 没有条件的switch，如switch {},同switch true {}一样 4.defer语句 defer 语句会延迟函数的执行直到上层函数返回。 延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用 12345678package mainimport \"fmt\";func main()&#123; defer fmt.Println(\"world&amp;quot;) fmt.Print(\"hello\")&#125; defer栈，延迟的函数调用会被压入一个栈中。 1234567891011package mainimport \"fmt\"func main() &#123; fmt.Println(\"counting\") for i := 0; i &lt; 10; i++ &#123; defer fmt.Println(i) &#125; fmt.Println(\"done\")&#125; 输出结果如下： 12345678910111213[Running] go run \"/Users/badwolf/Documents/go/hello/defer.go\"countingdone9876543210","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"ssh免密码登陆","slug":"ssh-e5-85-8d-e5-af-86-e7-a0-81-e7-99-bb-e9-99-86","date":"2017-08-30T01:56:25.000Z","updated":"2017-09-19T14:09:42.000Z","comments":true,"path":"2017/08/30/ssh-e5-85-8d-e5-af-86-e7-a0-81-e7-99-bb-e9-99-86/","link":"","permalink":"http://yoursite.com/2017/08/30/ssh-e5-85-8d-e5-af-86-e7-a0-81-e7-99-bb-e9-99-86/","excerpt":"","text":"有三台机器172.21.3.124/125/126，需要在这三台机器配置免密码登陆能够互相访问 1.在一台机器上执行命令，如172.21.3.124，期间会输入三次回车 ssh-keygen -t rsa 2.命令会在当前用户的家目录的.ssh的目录下生成id_rsa和id_rsa.pub文件，将id_rsa.pub文件copy到其他主机(172.21.3.125)的.ssh/authorized_keys目录下 因为我的是root用户，所以copy到/root/.ssh目录下。 3.这样再登陆172.21.3.125就可以不用输入密码了。需要注意的是 authorized_keys的权限需要是600。(chmod 600 .ssh/authorized_keys) 将id_rsa.pub文件Copy到172.21.3.126上就可以免密码登陆到172.21.3.126了。 将以上的命令和步骤重复在172.21.3.125/126分别执行， 注意已经存在authorized_keys文件不能覆盖，需要在文件内容后追加其他主机的id_rsa.pub的内容。 这样就可以三台机器 间互相免密码访问了。","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"python *args **kwargs理解","slug":"python-args-kwargs-e7-90-86-e8-a7-a3","date":"2017-08-29T06:42:18.000Z","updated":"2017-09-19T14:10:22.000Z","comments":true,"path":"2017/08/29/python-args-kwargs-e7-90-86-e8-a7-a3/","link":"","permalink":"http://yoursite.com/2017/08/29/python-args-kwargs-e7-90-86-e8-a7-a3/","excerpt":"","text":"*args表示任意多个无名参数，是个tuple（元组） **kwargs表示关键字参数，是个dict（字典） 这两个是python中的可变参数 注意：同时使用args和**kwargs时，args参数必须在**kwargs前边 123456789def foo(*args, **kwargs): print 'args = ', args print 'kwargs = ', kwargs if name == '__main__': foo(1,2,3,4) foo(a=1, b=2, c=3, d=4) foo(1,2,3,4,a=1, b=2, c=3, b=4) foo('a', 1, None, a=1, b='2', c=3)","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"Go 指南学习笔记一","slug":"golang-tour-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-80","date":"2017-08-28T08:37:36.000Z","updated":"2017-09-19T14:28:42.000Z","comments":true,"path":"2017/08/28/golang-tour-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-80/","link":"","permalink":"http://yoursite.com/2017/08/28/golang-tour-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-80/","excerpt":"","text":"Golang提供了官方的学习手册，tour地址：https://tour.go-zh.org同时，鉴于国内的网络环境，可以自己安装进行离线访问Go指南 1go get github.com/Go-zh/tour/gotour 然后就可以得到go tour了 12cd $GOPATH/bin./gotour 2.包 每个 Go 程序都是由包组成的。 程序运行的入口是包 main 。 一般情况下，包名与导入路径的最后一个目录一致。 3.包的导入 12import \"fmt\"import \"math\" 或者更多时候是下面的导入形式 1234import ( \"fmt\" \"math\") 4.大小写 首字母大写的名字是被导出的，可以被其他包引用，名称为小写的名称不会被导出 如： 可以引用fmt.Println()，而不能是fmt.println() 5.函数定义 123func add(x int, y int) int&#123; return x + y&#125; Golang和其他语言不同，变量名在类型之前,函数返回值再最后。 如果参数类型相同，则可以合并，如上可以写成 x, y int 。 函数返回值可以返回多个，形式为(int, int) 6.变量定义 var x ,y 可以定义在包级别或者函数级别。 函数赋值var x int = 1,可以省略类型，如var x = 1。 更可以简写成x :=1,这种情况下不能在函数外使用。 变量在没有初始化为默认为零值： 数值类型为 0 ， 布尔类型为 false ， 字符串为 &quot;&quot; （空字符串）不同类型之间的转换需要显示转换,如 int(i) 7.常量 常量定义与变量类似，不同的是不能使用:=定义","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Ubuntu及mac下安装配置openvpn客户端","slug":"ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af","date":"2017-08-28T06:00:00.000Z","updated":"2017-09-19T16:22:22.000Z","comments":true,"path":"2017/08/28/ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af/","link":"","permalink":"http://yoursite.com/2017/08/28/ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af/","excerpt":"","text":"Ubuntu下安装1.安装openvpn客户端 sudo apt-get install openvpn 2.配置文件 复制认证所需要的文件(ca.crt xxxxx_client_vpn.ovpn xxxxx.crt xxxxx.key ta.key)到/etc/openvpn目录下 3.启动openvpn客户端 sudo openvpn /etc/openvpn/xxxxx_client_vpn.ovpn 注意：命令需要在/etc/openvpn目录下执行，否则可能出现No such file or directory错误 MAC下安装 MAC有tunnelblick软件进行图形化安装，下边主要是通过命令行安装 1.安装brew2.通过brew进行安装 brew install openvpn To have launchd start openvpn now and restart at startup（如果想要启动openvpn或者在启动时重启可以执行命令）: sudo brew services start openvpn 3.安装目录 /usr/local/Cellar/openvpn/2.4.3/ 4.在xxxxx_client_vpn.ovpn所在目录执行命令 sudo /usr/local/Cellar/openvpn/2.4.3/sbin/openvpn ./xxxxx_client_vpn.ovpn","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"CentOS7安装nginx","slug":"centos7-e5-ae-89-e8-a3-85nginx","date":"2017-08-28T05:58:53.000Z","updated":"2017-09-19T13:32:49.000Z","comments":true,"path":"2017/08/28/centos7-e5-ae-89-e8-a3-85nginx/","link":"","permalink":"http://yoursite.com/2017/08/28/centos7-e5-ae-89-e8-a3-85nginx/","excerpt":"","text":"CentOS7上通过yum的方式安装nginx: 1.增加CentOS 7 EPEL repository sudo yum install -y epel-release 2.安装nginx sudo yum install -y nginx 3.启动nginx服务 sudo systemctl start nginx 4.如果在docker中安装nginx，Dockerfile如下： 1234567FROM cenos:7CMD yum install -y epel-releaseCMD yum install -y nginxENTRYPOINT [\"nginx\", \"-g\", \"daemon off;\"] 在docker中不能使用systemctl start nginx命令启动nginx","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"Jenkins插件开发","slug":"jenkins-e6-8f-92-e4-bb-b6-e5-bc-80-e5-8f-91","date":"2017-08-28T05:57:47.000Z","updated":"2017-09-19T13:32:50.000Z","comments":true,"path":"2017/08/28/jenkins-e6-8f-92-e4-bb-b6-e5-bc-80-e5-8f-91/","link":"","permalink":"http://yoursite.com/2017/08/28/jenkins-e6-8f-92-e4-bb-b6-e5-bc-80-e5-8f-91/","excerpt":"","text":"1.官网开发指南 https://wiki.jenkins.io/display/JENKINS/Plugin+tutorial 2.修改Maven的settting.xml文件 12345678910111213141516171819202122232425262728293031323334&lt;settings&gt; &lt;pluginGroups&gt; &lt;pluginGroup&gt;org.jenkins-ci.tools&lt;/pluginGroup&gt; &lt;/pluginGroups&gt; &lt;profiles&gt; &lt;!-- Give access to Jenkins plugins --&gt; &lt;profile&gt; &lt;id&gt;jenkins&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;!-- change this to false, if you don't like to have it on per default --&gt; &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt; &lt;url&gt;https://repo.jenkins-ci.org/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt; &lt;url&gt;https://repo.jenkins-ci.org/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;repo.jenkins-ci.org&lt;/id&gt; &lt;url&gt;https://repo.jenkins-ci.org/public/&lt;/url&gt; &lt;mirrorOf&gt;m.g.o-public&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 3.创建新的插件，在命令行执行 mvn -U org.jenkins-ci.tools:maven-hpi-plugin:create 过程中要求输入插件的groupId和artifactId 编译新建的插件 mvn install 4.本地调试： set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000,suspend=n mvn hpi:run","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"npm设置代理服务器","slug":"npm-e8-ae-be-e7-bd-ae-e4-bb-a3-e7-90-86-e6-9c-8d-e5-8a-a1-e5-99-a8","date":"2017-08-28T05:55:46.000Z","updated":"2017-09-19T14:01:46.000Z","comments":true,"path":"2017/08/28/npm-e8-ae-be-e7-bd-ae-e4-bb-a3-e7-90-86-e6-9c-8d-e5-8a-a1-e5-99-a8/","link":"","permalink":"http://yoursite.com/2017/08/28/npm-e8-ae-be-e7-bd-ae-e4-bb-a3-e7-90-86-e6-9c-8d-e5-8a-a1-e5-99-a8/","excerpt":"","text":"1.设置代理命令 12npm config set proxy http://username:password@127.0.0.1:8080npm config set https-proxy http://username:password@127.0.0.1:8080 2.删除代理命令 12npm config delete https-proxynpm config delete proxy 3.查看代理设置 12npm config get proxynpm config get https-proxy","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/categories/nodejs/"}],"tags":[]},{"title":"Ubuntu以及MAC下安装配置openvpn客户端","slug":"ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af-trashed","date":"2017-08-22T14:25:41.000Z","updated":"2017-09-19T16:22:43.000Z","comments":true,"path":"2017/08/22/ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af-trashed/","link":"","permalink":"http://yoursite.com/2017/08/22/ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af-trashed/","excerpt":"","text":"Ubuntu下安装1.安装openvpn客户端 sudo apt-get install openvpn 2.配置文件 复制认证所需要的文件(ca.crt xxxxx_client_vpn.ovpn xxxxx.crt xxxxx.key ta.key)到/etc/openvpn目录下 3.启动openvpn客户端 sudo openvpn /etc/openvpn/xxxxx_client_vpn.ovpn 注意：命令需要在/etc/openvpn目录下执行，否则可能出现No such file or directory错误 MAC下安装MAC有tunnelblick软件进行图形化安装，下边主要是通过命令行安装 1.安装brew2.通过brew进行安装 brew install openvpn To have launchd start openvpn now and restart at startup（如果想要启动openvpn或者在启动时重启可以执行命令）: sudo brew services start openvpn 3.安装目录 /usr/local/Cellar/openvpn/2.4.3/ 4.在xxxxx_client_vpn.ovpn所在目录执行命令 sudo /usr/local/Cellar/openvpn/2.4.3/sbin/openvpn ./xxxxx_client_vpn.ovpn","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"CentOS7安装nginx","slug":"centos7-e5-ae-89-e8-a3-85nginx-trashed","date":"2017-08-22T13:52:56.000Z","updated":"2017-09-19T13:32:49.000Z","comments":true,"path":"2017/08/22/centos7-e5-ae-89-e8-a3-85nginx-trashed/","link":"","permalink":"http://yoursite.com/2017/08/22/centos7-e5-ae-89-e8-a3-85nginx-trashed/","excerpt":"","text":"CentOS7上通过yum的方式安装nginx: 1.增加CentOS 7 EPEL repository sudo yum install -y epel-release 2.安装nginx sudo yum install -y nginx 3.启动nginx服务 sudo systemctl start nginx 4.如果在docker中安装nginx，Dockerfile如下： 1234567FROM cenos:7CMD yum install -y epel-releaseCMD yum install -y nginxENTRYPOINT [\"nginx\", \"-g\", \"daemon off;\"] 在docker中不能使用systemctl start nginx命令启动nginx","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]}]}