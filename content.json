{"meta":{"title":"BADWOLFBAY","subtitle":null,"description":null,"author":"badwolf","url":"http://yoursite.com"},"pages":[{"title":"Blog","date":"2017-08-22T20:56:03.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"blog/index.html","permalink":"http://yoursite.com/blog/index.html","excerpt":"","text":""},{"title":"首页","date":"2017-08-22T20:56:03.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"e9-a6-96-e9-a1-b5-trashed/index.html","permalink":"http://yoursite.com/e9-a6-96-e9-a1-b5-trashed/index.html","excerpt":"","text":"欢迎来到您的站点！这是您的主页，也就是大多数访客第一次造访时看到的页面。"},{"title":"示例页面","date":"2017-08-19T02:21:01.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"sample-page-trashed/index.html","permalink":"http://yoursite.com/sample-page-trashed/index.html","excerpt":"","text":"这是示范页面。页面和博客文章不同，它的位置是固定的，通常会在站点导航栏显示。很多用户都创建一个“关于”页面，向访客介绍自己。例如： 欢迎！我白天是个邮递员，晚上就是个有抱负的演员。这是我的博客。我住在天朝的帝都，有条叫做Jack的狗。 ……或这个： XYZ Doohickey公司成立于1971年，自从建立以来，我们一直向社会贡献着优秀doohickies。我们的公司总部位于天朝魔都，有着超过两千名员工，对魔都政府税收有着巨大贡献。 而您，作为一个WordPress用户，我们建议您访问控制板，删除本页面，然后添加您自己的页面。祝您使用愉快！"}],"posts":[{"title":"Go 指南学习笔记九","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b9-9d","date":"2017-09-16T04:17:04.000Z","updated":"2017-09-18T16:22:45.000Z","comments":true,"path":"2017/09/15/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b9-9d/","link":"","permalink":"http://yoursite.com/2017/09/15/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b9-9d/","excerpt":"","text":"1.接口，接口为一组方法定义的集合 和其它语言不同，类型实现接口不需要显示声明，不需要implements关键字 定义接口和实现接口互不依赖 1234567891011121314151617181920212223242526272829303132333435type Abser interface &#123; Abs() float64&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat 实现了 Abser a = &amp;v // a *Vertex 实现了 Abser // 下面一行，v 是一个 Vertex（而不是 *Vertex） // 所以没有实现 Abser。 a = v fmt.Println(a.Abs())&#125;","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记八","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ab","date":"2017-09-11T20:22:53.000Z","updated":"2017-09-18T14:46:24.000Z","comments":true,"path":"2017/09/11/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ab/","link":"","permalink":"http://yoursite.com/2017/09/11/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ab/","excerpt":"","text":"1.结构体方法 Go语言不像JAVA，没有类的定义，但是依然可以为结构体定义方法。 123456789101112131415package mainimport (\"fmt\"\"math\")type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X * v.X + v.Y * v.Y)&#125;func main()&#123; v := &amp;amp;Vertex&#123;3,4&#125; fmt.Println(v.Abs()) // 5&#125; 2.还可以对包内任意类型定义任意方法，但是不能对包外的类型或者基础类型定义方法 1234567891011121314151617181920package mainimport ( \"fmt\" \"math\")type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;func main()&#123; f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) // 1.4142135623730951&#125; 3.方法可以与类型和类型的指针相关联 如1中的Abs方法是作用的*Vertex指针类型上 1234func (v *Vertex) Scale(f float64)&#123; v.X = v.X * f v.Y = v.Y * f&#125; 与1234func (v Vertex) Scale(f float64)&#123; v.X = v.X * f v.Y = v.Y * f&#125; 的区别 v := *Vertex(3,5) v.Scale(5) 前边的是用*Vertex指针类型接受，是引用传递，所以会改变接受者v的原始值，而后边的是用变量（后者说是对象）接受，是值传递，会对v进行一份copy,而不会对原始值做更改。","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记七","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-83","date":"2017-09-08T04:37:40.000Z","updated":"2017-09-18T14:48:33.000Z","comments":true,"path":"2017/09/07/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-83/","link":"","permalink":"http://yoursite.com/2017/09/07/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-83/","excerpt":"","text":"闭包 函数也是一个值，也可以像其它值一样传递。函数值也可以作为参数或者返回值 闭包是一个函数值，他引用了函数体之外的变量 这个函数值可以对引用的变量进行修改或者赋值 12345678910111213141516171819202122package mainimport ( \"fmt\")func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println( pos(i), neg(-2*i), ) &#125;&#125; 输出结果： 12345678910111213[Running] go run \"/Users/badwolf/Documents/go/hello/tempCodeRunnerFile.go\"0 01 -23 -66 -1210 -2015 -3021 -4228 -5636 -7245 -90[Done] exited with code=0 in 0.605 seconds","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"zookeeper安装","slug":"zookeeper-e5-ae-89-e8-a3-85","date":"2017-09-06T17:33:09.000Z","updated":"2017-09-18T14:51:44.000Z","comments":true,"path":"2017/09/06/zookeeper-e5-ae-89-e8-a3-85/","link":"","permalink":"http://yoursite.com/2017/09/06/zookeeper-e5-ae-89-e8-a3-85/","excerpt":"","text":"1.下载安装文件，下载地址：http://mirrors.hust.edu.cn/apache/zookeeper/ 这里的下载的版本为zookeeper-3.4.10.tar.gz 2.解压下载的安装文件 tar -zxvf&amp;nbsp;zookeeper-3.4.10.tar.gz 3.修改配置文件 zookeeper-3.4.10/conf mv zoo_sample.cfg zoo.cfg zoo.cfg可以根据需要修改配置信息,如clientPort=2181 4.启动zookeeper cd ../bin ./zkServer.sh start 启动成功信息： ZooKeeper JMX enabled by default Using config: /root/zookeeper-3.4.10/bin/../conf/zoo.cfg Starting zookeeper … STARTED 查看端口占用信息： netstat -an|grep 2181 5.客户端连接测试 ./zkCli.sh -server 127.0.0.1 连接成功后执行help命令可以查看帮助命令 [zk: 127.0.0.1(CONNECTED) 0] help ZooKeeper -server host:port cmd args &nbsp;&nbsp; &nbsp;stat path [watch] &nbsp;&nbsp; &nbsp;set path data [version] &nbsp;&nbsp; &nbsp;ls path [watch] &nbsp;&nbsp; &nbsp;delquota [-n|-b] path &nbsp;&nbsp; &nbsp;ls2 path [watch] &nbsp;&nbsp; &nbsp;setAcl path acl &nbsp;&nbsp; &nbsp;setquota -n|-b val path &nbsp;&nbsp; &nbsp;history&nbsp; &nbsp;&nbsp; &nbsp;redo cmdno &nbsp;&nbsp; &nbsp;printwatches on|off &nbsp;&nbsp; &nbsp;delete path [version] &nbsp;&nbsp; &nbsp;sync path &nbsp;&nbsp; &nbsp;listquota path &nbsp;&nbsp; &nbsp;rmr path &nbsp;&nbsp; &nbsp;get path [watch] &nbsp;&nbsp; &nbsp;create [-s] [-e] path data acl &nbsp;&nbsp; &nbsp;addauth scheme auth &nbsp;&nbsp; &nbsp;quit&nbsp; &nbsp;&nbsp; &nbsp;getAcl path &nbsp;&nbsp; &nbsp;close&nbsp; &nbsp;&nbsp; &nbsp;connect host:port","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"Go 指南学习笔记六","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ad","date":"2017-09-05T16:48:36.000Z","updated":"2017-09-18T14:57:31.000Z","comments":true,"path":"2017/09/05/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ad/","link":"","permalink":"http://yoursite.com/2017/09/05/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-85-ad/","excerpt":"","text":"1.map map在使用之前必须使用make来创建，值为nil的map是空的，并且不能对它赋值 1234567891011121314151617package mainimport ( \"fmt\")type Vertex struct&#123; Lat, Long float64&#125;var m map[string]Vertexfunc main() &#123; m = make(map[string]Vertex) m[\"Bell Labs\"] = Vertex&#123;40.68433, -74.39967&#125; fmt.Println(m[\"Bell Labs\"])// &#123;40.68433 -74.39967&#125;&#125; 2.和结构体语法类似 12345var n = map[string]Vertex &#123; \"Bell Labs\": Vertex&#123;40.68433, -74.39967,&#125;, \"Google\":Vertex&#123;37.42202, -122.08408,&#125;,&#125;fmt.Println(n) //map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;] 如果map的value值只是一个类型，可以在{}中将类型省略 1234var k = map[string]Vertex&#123; \"Bell Labs\": &#123;40.68433, -74.39967&#125;, \"Google\": &#123;37.42202, -122.08408&#125;,&#125; 3.修改map 插入或者修改元素: m[key] =&nbsp;elem 获得元素:&nbsp;elem = m[key] 删除元素: delete(m,key) 检测是否存在: elem, ok = m[key]","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记五","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-94","date":"2017-09-04T06:28:42.000Z","updated":"2017-09-18T16:20:12.000Z","comments":true,"path":"2017/09/03/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-94/","link":"","permalink":"http://yoursite.com/2017/09/03/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-94/","excerpt":"","text":"1.数组：类型[n]T是有n个值的类型为T的数组 var a [10] int变量a是一个有10个整数的数组。 数组不能改变大小 12package main import \"fmt\" func main() &#123; var a [10]string a[0] = \"hello\" a[1] = \"world\" fmt.Println(a[0], a[1]) //hello world fmt.Println(a) // [hello world &#125; 2.slice（切片）,[]T为一个类型为T的slice,len(s)返回切片s的长度 123456789101112131415161718192021222324252627&gt; s := []int&#123;2, 3, 5, 7, 11, 13&#125; &gt; &gt; &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fmt.Println(&amp;quot;s == &amp;quot;, s) &gt; &gt; &gt; &amp;nbsp; &gt; &gt; &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for i := 0; i &amp;lt; len(s); i++ &#123; &gt; &gt; &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fmt.Printf(&amp;quot;s[%d] = %d\\n\", i, s[i]) &gt; &gt; &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#125; &gt; &gt; &gt; //输出结果 &gt; &gt; &gt; s == [2 3 5 7 11 13] &gt; &gt; &gt; s[0] = 2 &gt; &gt; &gt; s[1] = 3 &gt; &gt; &gt; s[2] = 5 &gt; &gt; &gt; s[3] = 7 &gt; &gt; &gt; s[4] = 11 &gt; &gt; &gt; s[5] = 13 3.slice 可以包含任意的类型，包括另一个 slice。 12345678910&gt; game := [][] string&#123; &gt; &gt; &gt; &amp;nbsp; &amp;nbsp; []string&#123;&amp;quot;_&amp;quot;,&amp;quot;_&amp;quot;,&amp;quot;_&amp;quot;&#125;, &gt; &gt; &gt; &amp;nbsp; &amp;nbsp;&amp;nbsp;[]string&#123;&amp;quot;_&amp;quot;,&amp;quot;_&amp;quot;,&amp;quot;_&amp;quot;&#125;, &gt; &gt; &gt; &amp;nbsp; &amp;nbsp; []string&#123;&amp;quot;_&amp;quot;,&amp;quot;_&amp;quot;,&amp;quot;_&amp;quot;&#125;, &gt; &gt; &gt; &#125; 4.对slice切片 s[lo:hi] // 包含lo元素，不包含hi元素 5.构造slice,slice由make创建，这会分配一个全是零值的数组并返回一个slice并指向这个数组 a := make([]int, 5) 可以传递第三个参数来执行容量 b := make([]int, 0 , 5) &nbsp; &nbsp;// len(b) = 0, cap(b) = 5 如： func printlnSlice(s string, x []int) { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fmt.Printf(&amp;quot;%s len=%d, cap=%d %v\\n&amp;quot;, s, len(x), cap(x), x) } &amp;nbsp; func main() { &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a := make([]int, 5) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printlnSlice(&amp;quot;a&amp;quot;, a) &amp;nbsp;//&amp;nbsp;a len=5, cap=5 [0 0 0 0 0] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b := make([]int, 0, 5) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printlnSlice(&amp;quot;b&amp;quot;, b) &amp;nbsp;//&amp;nbsp;b len=0, cap=5 [] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c := b[:2] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printlnSlice(&amp;quot;c&amp;quot;, c) //&amp;nbsp;c len=2, cap=5 [0 0] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;d := c[2:5] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printlnSlice(&amp;quot;d&amp;quot;, d) //d len=3, cap=3 [0 0 0] &amp;nbsp; } 6.向slice结尾添加元素，append var a []int append(a, 0) append(a, 1) append(a, 2, 3, 4) 如果slice底层数组的不能分配更多的数组时，会自动分配一个更大的数组，返回的slice指向新的数组。 7.切片是数组之上的抽象数据类型。 初始化不同,切片不需要指定固定长度:var a [10]int//数组var a []int//切片 切片的零值是nil 更多的slice切片：用法与本质","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记四","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-9b-9b","date":"2017-09-03T03:57:40.000Z","updated":"2017-09-18T16:20:12.000Z","comments":true,"path":"2017/09/02/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-9b-9b/","link":"","permalink":"http://yoursite.com/2017/09/02/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e5-9b-9b/","excerpt":"","text":"1.结构体struct 1type Vertex struct &#123; X int Y int &#125; func main()&#123; v := Vertex&#123;1,2&#125; v.X = 4 fmt.Println(v.X) &amp;nbsp; // 4 &#125; 2.结构体指针 1v := Vertex&#123;1,2&#125; p := &amp;amp;v p.X = 1e9 fmt.Println(p.X) &amp;nbsp;//1000000000 3.结构体语法，可以仅列出部分字段；&amp;可以指向结构体的指针 1var ( v1 = Vertex&#123;1, 2&#125; v2 = Vertex&#123;X: 1&#125; v3 = Vertex&#123;&#125; p = *Vertex&#123;1, 2&#125; ) fmt.Println(v1, v2, v3, p)//&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125; *&#123;1 2&#125;","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记三","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-89","date":"2017-09-02T03:45:41.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/09/01/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-89/","link":"","permalink":"http://yoursite.com/2017/09/01/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-89/","excerpt":"","text":"1.指针：指针保存了变量的内存地址。 T是指向类型T的值指针，其零值是nil &amp;符号会生成一个其作用对象的指针 var p *int fmt.Println(p) i := 42 p = &amp;i fmt.Println(p)输出结果为 *表示指针指向底层的值 fmt.Println(p)并且可以通过修改指针修改底层的值 p = 21这就是常说的”间接引用”。与C语言不同，go语言的指针没有运算。 &nbsp;","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"利用Dockerhub+github自定义制作镜像","slug":"e5-88-a9-e7-94-a8dockerhubgithub-e8-87-aa-e5-ae-9a-e4-b9-89-e5-88-b6-e4-bd-9c-e9-95-9c-e5-83-8f","date":"2017-09-01T06:00:13.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/08/31/e5-88-a9-e7-94-a8dockerhubgithub-e8-87-aa-e5-ae-9a-e4-b9-89-e5-88-b6-e4-bd-9c-e9-95-9c-e5-83-8f/","link":"","permalink":"http://yoursite.com/2017/08/31/e5-88-a9-e7-94-a8dockerhubgithub-e8-87-aa-e5-ae-9a-e4-b9-89-e5-88-b6-e4-bd-9c-e9-95-9c-e5-83-8f/","excerpt":"","text":"Dockerhub可以根据github工程中Dockerfile自动生成镜像，一般情况下，我们需要google下gcr的镜像，因为网络原因连接不上，我们可以将Dockerfile文件提交到github,然后生成我们自己的镜像，如： 前提是已经注册自己的Dockerhub帐号，登录https://hub.docker.com 点击右上角Create -&gt; Create Automated Build &nbsp; 后登录自己的github帐号 从自己的github工程中选择要创建镜像的工程 后输入要生成的镜像名称 在Build Setting的Tab页中输入Dockerfile的位置以及tag /目录为相对于github中工程的位置，如github中Dockerfile在/centos下 则输入/centos，再点击save changes后，点击Trigger后就可以构建镜像了，后续如果github中代码有更改，构建动作会自动触发。点击build details可以查看每次构建日志 &nbsp;","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Go 指南学习笔记二","slug":"go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-8c","date":"2017-08-31T04:18:46.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/08/30/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-8c/","link":"","permalink":"http://yoursite.com/2017/08/30/go-e6-8c-87-e5-8d-97-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-ba-8c/","excerpt":"","text":"1.for循环 go语言只有一个循环语句，即for。如下 sum := 0 for i:= 0;i&amp;lt;10;i++{ &amp;nbsp; &amp;nbsp; sum += i } 不像java,python等，条件表达式不需要()小括号，循环体需要{} 初始化条件和后置判断条件不是必须的，如for ; i&lt;10; {} 在java等语言中while循环在go语言中写法 for i&lt; 10 { &amp;nbsp; &amp;nbsp; sum += i } 死循环 for { &amp;nbsp; &amp;nbsp; sum += i } 2.if语句 同for循环一样,if语句的判断条件语句也不需要() if i&lt;10 { } 同for循环一样，条件之前也可以是一个简单的语句 i := 10 if j:= 10; i&amp;lt;j { &amp;nbsp; &amp;nbsp; return j } else i := 10 if j := 10; i&amp;lt;j { &amp;nbsp; &amp;nbsp; return j } else { &amp;nbsp; &amp;nbsp; return i } 3.switch语句 package main &amp;nbsp; import ( &amp;nbsp; &amp;nbsp; &amp;quot;fmt&amp;quot; &amp;nbsp; &amp;nbsp; &amp;quot;runtime&amp;quot; ) &amp;nbsp; func main() { &amp;nbsp; &amp;nbsp; fmt.Print(&amp;quot;Go runs on &amp;quot;) &amp;nbsp; &amp;nbsp; switch os := runtime.GOOS; os { &amp;nbsp; &amp;nbsp; case &amp;quot;darwin&amp;quot;: &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Println(&amp;quot;OS X.&amp;quot;) &amp;nbsp; &amp;nbsp; case &amp;quot;linux&amp;quot;: &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Println(&amp;quot;Linux.&amp;quot;) &amp;nbsp; &amp;nbsp; default: &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Printf(&amp;quot;%s.&amp;quot;, os) &amp;nbsp; &amp;nbsp; } } 按照条件从上到下执行，直到匹配到成功为止，执行成功后，后边的条件不再执行 没有条件的switch，如switch {},同switch true {}一样 4.defer语句 defer 语句会延迟函数的执行直到上层函数返回。 延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用 package main import &amp;quot;fmt&amp;quot; func main(){ &amp;nbsp; &amp;nbsp; defer fmt.Println(&amp;quot;world&amp;quot;) &amp;nbsp; &amp;nbsp; fmt.Print(&amp;quot;hello&amp;quot;) } defer栈，延迟的函数调用会被压入一个栈中。 package main &lt;div&gt; import &amp;quot;fmt&amp;quot; &lt;/div&gt; &lt;div&gt; func main() { &lt;/div&gt; &lt;div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fmt.Println(&amp;quot;counting&amp;quot;) &lt;/div&gt; &lt;div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for i := 0; i &amp;lt; 10; i++ { &lt;/div&gt; &lt;div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;defer fmt.Println(i) &lt;/div&gt; &lt;div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} &lt;/div&gt; &lt;div&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fmt.Println(&amp;quot;done&amp;quot;) &lt;/div&gt; &lt;div&gt; } &lt;/div&gt; &amp;nbsp; &lt;/div&gt; 输出结果如下图： ![](http://www.badwolfbay.cn/wp-content/uploads/2017/08/QQ20170830-211806@2x-300x97.png)","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"ssh免密码登陆","slug":"ssh-e5-85-8d-e5-af-86-e7-a0-81-e7-99-bb-e9-99-86","date":"2017-08-30T16:56:25.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/08/30/ssh-e5-85-8d-e5-af-86-e7-a0-81-e7-99-bb-e9-99-86/","link":"","permalink":"http://yoursite.com/2017/08/30/ssh-e5-85-8d-e5-af-86-e7-a0-81-e7-99-bb-e9-99-86/","excerpt":"","text":"有三台机器172.21.3.124/125/126，需要在这三台机器配置免密码登陆能够互相访问 1.在一台机器上执行命令，如172.21.3.124，期间会输入三次回车 ssh-keygen -t rsa 2.命令会在当前用户的家目录的.ssh的目录下生成id_rsa和id_rsa.pub文件，将id_rsa.pub文件copy到其他主机(172.21.3.125)的.ssh/authorized_keys目录下 因为我的是root用户，所以copy到/root/.ssh目录下。 3.这样再登陆172.21.3.125就可以不用输入密码了。需要注意的是 authorized_keys的权限需要是600。(chmod 600 .ssh/authorized_keys) 将id_rsa.pub文件Copy到172.21.3.126上就可以免密码登陆到172.21.3.126了。 将以上的命令和步骤重复在172.21.3.125/126分别执行， 注意已经存在authorized_keys文件不能覆盖，需要在文件内容后追加其他主机的id_rsa.pub的内容。 这样就可以三台机器 间互相免密码访问了。 &nbsp; &nbsp;","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"python *args **kwargs理解","slug":"python-args-kwargs-e7-90-86-e8-a7-a3","date":"2017-08-29T21:42:18.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/08/29/python-args-kwargs-e7-90-86-e8-a7-a3/","link":"","permalink":"http://yoursite.com/2017/08/29/python-args-kwargs-e7-90-86-e8-a7-a3/","excerpt":"","text":"1. *args表示任意多个无名参数，是个tuple（元组） 2\\. **kwargs表示关键字参数，是个dict（字典） 这两个是python中的可变参数 注意：同时使用*args和**kwargs时，*args参数必须在**kwargs前边 &nbsp; def foo(*args, **kwargs): &amp;nbsp; &amp;nbsp; print &amp;#39;args = &amp;#39;, args &amp;nbsp; &amp;nbsp; print &amp;#39;kwargs = &amp;#39;, kwargs &amp;nbsp; if name == &#39;main&#39;: &amp;nbsp; &amp;nbsp; foo(1,2,3,4) &amp;nbsp; &amp;nbsp; foo(a=1, b=2, c=3, d=4) &amp;nbsp; &amp;nbsp; foo(1,2,3,4,a=1, b=2, c=3, b=4) &amp;nbsp; &amp;nbsp; foo(&amp;#39;a&amp;#39;, 1, None, a=1, b=&amp;#39;2&amp;#39;, c=3)","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[]},{"title":"Go 指南学习笔记一","slug":"golang-tour-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-80","date":"2017-08-28T23:37:36.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/08/28/golang-tour-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-80/","link":"","permalink":"http://yoursite.com/2017/08/28/golang-tour-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-e4-b8-80/","excerpt":"","text":"Golang提供了官方的学习手册，tour地址：https://tour.go-zh.org同时，鉴于国内的网络环境，可以自己安装进行离线访问Go指南 go get github.com/Go-zh/tour/gotour然后就可以得到go tour了cd $GOPATH/bin ./gotour2.包 每个 Go 程序都是由包组成的。 程序运行的入口是包 main 。 一般情况下，包名与导入路径的最后一个目录一致。 3.包的导入 import “fmt” import “math”或者更多时候是下面的导入形式import ( “fmt” “math” )4.大小写 首字母大写的名字是被导出的，可以被其他包引用，名称为小写的名称不会被导出 如： 可以引用fmt.Println()，而不能是fmt.println() 5.函数定义 func add(x int, y int) int{ return x + y }Golang和其他语言不同，变量名在类型之前,函数返回值再最后。 如果参数类型相同，则可以合并，如上可以写成 x, y int 。 函数返回值可以返回多个，形式为(int, int) 6.变量定义 var x ,y可以定义在包级别或者函数级别。 函数赋值var x int = 1,可以省略类型，如var x = 1。 更可以简写成x :=1,这种情况下不能在函数外使用。 变量在没有初始化为默认为零值： 数值类型为 0 ， 布尔类型为 false ， 字符串为 &quot;&quot; （空字符串）不同类型之间的转换需要显示转换,如 int(i) 7.常量 常量定义与变量类似，不同的是不能使用:=定义 &nbsp;","categories":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/categories/golang/"}],"tags":[]},{"title":"Ubuntu下安装配置openvpn客户端","slug":"ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af","date":"2017-08-28T21:00:01.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/08/28/ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af/","link":"","permalink":"http://yoursite.com/2017/08/28/ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af/","excerpt":"","text":"1.安装openvpn客户端 sudo apt-get install openvpn 2.配置文件 复制认证所需要的文件(ca.crt xxxxx_client_vpn.ovpn xxxxx.crt xxxxx.key ta.key)到/etc/openvpn目录下 3.启动openvpn客户端 sudo openvpn /etc/openvpn/xxxxx_client_vpn.ovpn 注意：命令需要在/etc/openvpn目录下执行，否则可能出现No such file or directory错误","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"CentOS7安装nginx","slug":"centos7-e5-ae-89-e8-a3-85nginx","date":"2017-08-28T20:58:53.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/08/28/centos7-e5-ae-89-e8-a3-85nginx/","link":"","permalink":"http://yoursite.com/2017/08/28/centos7-e5-ae-89-e8-a3-85nginx/","excerpt":"","text":"CentOS7上通过yum的方式安装nginx: 1.增加CentOS 7 EPEL repository sudo yum install -y epel-release 2.安装nginx sudo yum install -y nginx 3.启动nginx服务 sudo systemctl start nginx 4.如果在docker中安装nginx，Dockerfile如下： FROM cenos:7 CMD yum install -y epel-release CMD yum install -y nginx ENTRYPOINT [“nginx”, “-g”, “daemon off;”] 在docker中不能使用systemctl start nginx命令启动nginx","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"Jenkins插件开发","slug":"jenkins-e6-8f-92-e4-bb-b6-e5-bc-80-e5-8f-91","date":"2017-08-28T20:57:47.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/08/28/jenkins-e6-8f-92-e4-bb-b6-e5-bc-80-e5-8f-91/","link":"","permalink":"http://yoursite.com/2017/08/28/jenkins-e6-8f-92-e4-bb-b6-e5-bc-80-e5-8f-91/","excerpt":"","text":"1.官网开发指南 https://wiki.jenkins.io/display/JENKINS/Plugin+tutorial 2.修改Maven的settting.xml文件 &amp;lt;``settings``&amp;gt; ``&amp;lt;``pluginGroups``&amp;gt; ``&amp;lt;``pluginGroup``&amp;gt;org.jenkins-ci.tools&amp;lt;/``pluginGroup``&amp;gt; ``&amp;lt;/``pluginGroups``&amp;gt; ``&amp;lt;``profiles``&amp;gt; ``&amp;lt;!-- Give access to Jenkins plugins --&amp;gt; ``&amp;lt;``profile``&amp;gt; ``&amp;lt;``id``&amp;gt;jenkins&amp;lt;/``id``&amp;gt; ``&amp;lt;``activation``&amp;gt; ``&amp;lt;``activeByDefault``&amp;gt;true&amp;lt;/``activeByDefault``&amp;gt; ``&amp;lt;!-- change this to false, if you don&#39;t like to have it on per default --&amp;gt; ``&amp;lt;/``activation``&amp;gt; ``&amp;lt;``repositories``&amp;gt; ``&amp;lt;``repository``&amp;gt; ``&amp;lt;``id``&amp;gt;repo.jenkins-ci.org&amp;lt;/``id``&amp;gt; ``&amp;lt;``url``&amp;gt;[https://repo.jenkins-ci.org/public/](https://repo.jenkins-ci.org/public/)&amp;lt;/``url``&amp;gt; ``&amp;lt;/``repository``&amp;gt; ``&amp;lt;/``repositories``&amp;gt; ``&amp;lt;``pluginRepositories``&amp;gt; ``&amp;lt;``pluginRepository``&amp;gt; ``&amp;lt;``id``&amp;gt;repo.jenkins-ci.org&amp;lt;/``id``&amp;gt; ``&amp;lt;``url``&amp;gt;[https://repo.jenkins-ci.org/public/](https://repo.jenkins-ci.org/public/)&amp;lt;/``url``&amp;gt; ``&amp;lt;/``pluginRepository``&amp;gt; ``&amp;lt;/``pluginRepositories``&amp;gt; ``&amp;lt;/``profile``&amp;gt; ``&amp;lt;/``profiles``&amp;gt; ``&amp;lt;``mirrors``&amp;gt; ``&amp;lt;``mirror``&amp;gt; ``&amp;lt;``id``&amp;gt;repo.jenkins-ci.org&amp;lt;/``id``&amp;gt; ``&amp;lt;``url``&amp;gt;[https://repo.jenkins-ci.org/public/](https://repo.jenkins-ci.org/public/)&amp;lt;/``url``&amp;gt; ``&amp;lt;``mirrorOf``&amp;gt;m.g.o-public&amp;lt;/``mirrorOf``&amp;gt; ``&amp;lt;/``mirror``&amp;gt; ``&amp;lt;/``mirrors``&amp;gt; &amp;lt;/``settings``&amp;gt;3.创建新的插件，在命令行执行mvn -U org.jenkins-ci.tools:maven-hpi-plugin:create过程中要求输入插件的groupId和artifactId 编译新建的插件 mvn install&nbsp; 4.本地调试： set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000,suspend=n&nbsp;mvn hpi:run&nbsp; &nbsp; &nbsp;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"npm设置代理服务器","slug":"npm-e8-ae-be-e7-bd-ae-e4-bb-a3-e7-90-86-e6-9c-8d-e5-8a-a1-e5-99-a8","date":"2017-08-28T20:55:46.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/08/28/npm-e8-ae-be-e7-bd-ae-e4-bb-a3-e7-90-86-e6-9c-8d-e5-8a-a1-e5-99-a8/","link":"","permalink":"http://yoursite.com/2017/08/28/npm-e8-ae-be-e7-bd-ae-e4-bb-a3-e7-90-86-e6-9c-8d-e5-8a-a1-e5-99-a8/","excerpt":"","text":"1.设置代理命令 npm config set proxy http://username:password@127.0.0.1:8080 npm config set https-proxy http://username:password@127.0.0.1:80802.删除代理命令 npm config delete https-proxy npm config delete proxy3.查看代理设置npm config get proxy npm config get https-proxy","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/categories/nodejs/"}],"tags":[]},{"title":"Ubuntu下安装配置openvpn客户端","slug":"ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af-trashed","date":"2017-08-23T05:25:41.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/08/22/ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af-trashed/","link":"","permalink":"http://yoursite.com/2017/08/22/ubuntu-e4-b8-8b-e5-ae-89-e8-a3-85-e9-85-8d-e7-bd-aeopenvpn-e5-ae-a2-e6-88-b7-e7-ab-af-trashed/","excerpt":"","text":"1.安装openvpn客户端 sudo apt-get install openvpn 2.配置文件 复制认证所需要的文件(ca.crt xxxxx_client_vpn.ovpn xxxxx.crt xxxxx.key ta.key)到/etc/openvpn目录下 3.启动openvpn客户端 sudo openvpn /etc/openvpn/xxxxx_client_vpn.ovpn 注意：命令需要在/etc/openvpn目录下执行，否则可能出现No such file or directory错误","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"CentOS7安装nginx","slug":"centos7-e5-ae-89-e8-a3-85nginx-trashed","date":"2017-08-23T04:52:56.000Z","updated":"2017-09-18T14:08:12.000Z","comments":true,"path":"2017/08/22/centos7-e5-ae-89-e8-a3-85nginx-trashed/","link":"","permalink":"http://yoursite.com/2017/08/22/centos7-e5-ae-89-e8-a3-85nginx-trashed/","excerpt":"","text":"CentOS7上通过yum的方式安装nginx: 1.增加CentOS 7 EPEL repository sudo yum install -y epel-release 2.安装nginx sudo yum install -y nginx 3.启动nginx服务 sudo systemctl start nginx 4.如果在docker中安装nginx，Dockerfile如下： FROM cenos:7 CMD yum install -y epel-release CMD yum install -y nginx ENTRYPOINT [“nginx”, “-g”, “daemon off;”] 在docker中不能使用systemctl start nginx命令启动nginx","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]}]}